# 데이터 모델과 성능

## 정규화와 성능

### 1) 성능 데이터 모델링의 개요

#### 성능 데이터 모델링의 개념

- 성능 데이터 모델링은 분석/설계 단계부터 데이터베이스 성능을 고려한 데이터 모델링을 수행하는 기법
- SQL이 아닌 데이터 모델을 중심으로 성능에 대한 데이터 모델링을 수행한다.

![](https://dataonair.or.kr/publishing/img/knowledge/SQL_073.jpg)

#### 성능 데이터 모델링의 절차

- 논리 모델링 단계에서는 데이터베이스 정규화를 수행한다.
- 물리 모델링 단계에서는 용량산정과 트랜잭션 유형 파악을 통해 반 정규화를 수행하고, 이력 유형, PK/FK 순서, 슈퍼 타입/서브 타입을 통해 데이터 구조를 조정한다.

| 순서 |        절차        | 설명                                            |
| ---- | :----------------: | :---------------------------------------------- |
| 1    |       정규화       | 데이터 중복을 제거하여 데이터 처리 성능을 향상  |
| 2    |      용량산정      | 데이터베이스의 현재 용량과 예상 증가량을 조사   |
| 3    | 트랜잭션 유형 파악 | 데이터의 분할 및 조인 여부 조사                 |
| 4    |      반정규화      | 테이블, 컬럼, 관계에 대해 반정규화 수행         |
| 5    |  데이터 구조 조정  | 이력 유형, PK/FK 순서, 슈퍼 타입/서브 타입 조정 |
| 6    |  데이터 모델 검증  | 성능 관점에서 데이터 모델을 검증                |

### 2)데이터베이스 정규화

#### 데이터베이스 정규화(DB Normalization)의 개념

- 데이터베이스 정규화는 관계형 데이터 모델에서 데이터의 `중복성을 제거`하여 이상 현상을 방지하고 데이터의 일관성을 유지하기 위해 `무손실 분해`하는 과정이다.
- 함수적 종속성(Functional Dependency)의 성질을 이용해서 데이터베이스 정규화를 수행한다.

#### 함수적 종속성(Functional Dependency)

> 데이터베이스의 릴레이션 R(테이블)에서 X와 Y를 R의 부분집합이라고 할 때, X의 값 각각에 대해 Y의 값이 오직 하나로 결정 될때 Y는 X에 종속 된다고 한다.

- 함수적 종속성은 데이터가 가지고 있는 속성 간의 관계에 의해 결정되고 종속되는 현상이다.
- 데이터의 기준 값을 결정자(Determinant)라고 하고, 종속되는 값을 종속자(Dependent)라고 한다.

```mermaid
graph LR;
    a[결정자] --> b[종속자]
```

##### 함수적 종속성의 예시

```mermaid
graph LR;
    A["주민등록번호(결정자)"] --> B["이름,나이(종속자)"]
```

##### <span style="font-size:24px;">함수적 종속성의 유형</span>

- 완전 함수 종속성 : 식별자의 전체 속성이 다른 속성을 결정하는 경우
  |학생ID|과목코드|성정|
  |-|-|-|
  | 1001 | CS101 | A |
  | 1002 | CS102 | B |
  | 1003 | CS101 | A |
  | 1004 | CS103 | C |
  ```mermaid
  classDiagram
  class 학생 {
      학생ID
      과목코드
      성적
  }
  ```
  학생ID와 과목코드가 복합 기본 키일 때, 성적은 학생ID와 과목코드 전체에 의해 결정된다.<br>여기서 성적은 완전 함수 종속성을 가집니다.
  ```mermaid
  graph LR

      a["학생ID, 과목코드"] --> 성적
  ```
- 부분 함수 종속성 : 복합 식별자의 일부 속성이 다른 속성을 결정하는 경우
  | 학생ID | 과목코드 | 교수명 |
  |-|-|-|
  | 1001 | CS101 | 김교수 |
  | 1002 | CS102 | 이교수 |
  | 1003 | CS101 | 김교수 |
  | 1004 | CS103 | 박교수 |
  ```mermaid
  classDiagram
      class 학생 {
          학생ID
          과목코드
          교수명
      }
  ```
  학생ID와 과목코드가 복합 기본 키일 때, 교수명은 과목코드에 의해 결정된다.<br>즉, 학생ID만으로는 교수명을 결정할 수 없기 때문에, 교수명은 과목코드의 부분 종속성을 가진다.
  ```mermaid
  flowchart LR
      subgraph a[" "]
          st["학생ID"]
          s["과목코드"]
      end
      s --> 성적
      a --> 성적
  ```
- 이행 함수 종속성 : 어떤 속성 A가 다른 속성 B를 결정하고, B가 또 다른 속성 C를 결정하는 경우
  | 학생ID | 전공명 | 교수명 |
  |-|-|-|
  | 1001 | 컴퓨터공학 | 김교수 |
  | 1002 | 전자공학 | 이교수 |
  | 1003 | 컴퓨터공학 | 김교수 |
  | 1004 | 기계공학 | 박교수 |

  ```mermaid
  graph LR
    학생ID --> 전공명 --> 교수명
  ```
- 결정자 함수 종속성 : 결정자가 후보키가 아닌 일반 속성일 때의 함수 종속성. 즉, 후보키가 아닌 속성이 다른 속성을 결정하는 경우
```mermaid
flowchart
    subgraph s[" "]
        a["학번"]
        b["과목"]
    end
    a --> 교수
    교수 --> b
```
#### 데이터베이스 정규화 단계
데이터베이스 정규화는 함수적 종속성에 근거해서 수행한다
1. 1차 정규화 : 테이블 내의 속성값을 원자값으로 구성하는 단계
    |이름|이메일주소|
    |:-:|:-:|
    |홍길동|hong@sqld.net; gildong.hong@sqld.net|

    이메일 주소 속성에 2개의 중복되는 값이 존재한다. 속성을 원자값으로 구성하기위해 2개의 이메일 주소를 각각 레코드로 구성한다.

    |이름|이메일주소|
    |:-:|:-:|
    |홍길동|hong@sqld.net|
    |홍길동|gildong.hong@sqld.net|
2. 2차 정규화 : 부분 함수 종속성을 제거하는 단계, 일반 속성은 모두 완전 함수적 종속성 관계
    |학생|과목|담당교수|
    |:-:|-|-|
    |홍길동|데이터베이스|이순신|
    |장보고|데이터베이스|이순신|
    |허 준|소프트웨어 공학|스티브|
    
    //TODO : 그림 그리는것에 시간 너무 소요 나중에 채우며 재정리해보기
3. 3차 정규화 : 이행 함수 종속성을 제거하는 단계
4. BCNF(Boyce-Codd Normal Form) : 결정자 함수 종속성을 제거하는 단계
### 3)데이터베이스 정규화의 성능 고려사항
- 정구화를 하면 데이터 처리 조건에 따라 성능이 향상될 수도 있지만 반대로 저하될 수도 있다.
- 정규화로 인해 조인이 증가하는 경우에는 데이터 조회 성능이 저하될 수 있다.
- 데이터 조회와 입력/수정/삭제의 성능이 Trade-Off 되어 발생하기도 한다.

|처리유형|고려사항|
|:-:|-|
|조회|- 데이터 처리조건에 따라, 성능이 다르게 나타남<br>- 단일 테이블 조회시, 데이터 중복이 제거되어 조회 성능이 향상됨<br>- 다수의 테이블을 조인하여 조회하는 경우에는 I/O증가와 조인 연산으로 조회성능이 저하되기도 함|
|입력, 수정, 삭제|데이터 중복이 제거되어, 일반적으로 성능이 향상됨|
## 반정규화와 성능
### 1)반정규화(De-Normalization)의 개념
- 반정규화는 시스템의 성능 향상, 개발 및 운영의 단순화를 위해 정규화된 데이터 모델을 중복, 통합, 분리하는 데이터 모델링 기법이다.
- 반 정규화는 역정규화, 비정규화 라고도 한다.
### 2)반정규화 절차
- 반정규화는 대상을 조사하고, 다른 방법을 먼저 유도한 후 반 정규화를 수행한다.
- 반정규화는 데이터의 일관성을 유지하는 비용이 더 발생, 따라서 반경규화 수행 전 대안을 검토하는 작업을 선행해야한다.
### 3)반정규화 기법
반정규화 기법에는 테이블 반정규화, 컬럼 반정규화, 관계 반정규화가 있다.
### 4)반정규화의 성능 고려사항
- 중복성의 원리를 이용해서 데이터 조회 성능을 향상시키는 역할을 한다.
- 데이터를 조회할 때 디스크I/O양이 많아 성능 저하가 예상되는 경우 반정규화를 수행해 성능을 향상시킨다.
- 정규화로 인해 엔티티가 증가하고 조인의 개수가 많아지는 경우에 반정규화를 고려한다.
## 대용량 데이터에 따른 성능
### 1)대용량 데이터의 성능
|원인|설명|
|:-:|-|
|데이터의 양이<br>많은 경우|- 데이터의 양이 많아지면 인덱스의 용량이 커져서, 인덱스 변경이 필요한 입력, 수정, 삭제 트랜잭션에서 성능 저하가 발생<br>- 데이터양의 증가로 인덱스의 Tree 구조가 커지면, 인덱스 단계가 깊어지면서 조회 성능도 저하됨|
|컬럼의 수가<br>많은 경우|- 컬럼의 수가 많아지면 데이터가 다수 블록에 저장되므로, 다수의 I/O를 발생 시켜서 성능 저하가 발생<br>- 로우체이닝, 로우마이그레이션 현상 발생<br>- 트랜잭션이 접근하는 컬럼 유형을 분석해 테이블을 분리하면 디스크 I/O가 줄어 조회 성능을 향상시킬 수 있다.|
### 2)대용량 데이터의 성능 향상 방법
- 대용량 데이터의 성능 향상 방법에는 하나의 테이블을 다수의 파티션(Partition)으로 분리하는 파티셔닝 기법과 하나의 테이블을 다수의 테이블로 분할하는 수평 분할/수직 분할 방법이 있다.
- 파티셔닝의 결과는 하나의 테이블, 수평 분할/수직 분할의 결과는 다수의 테이블
#### 파티셔닝
- 대용량 테이블을 보다작은 파티션으로 관리함으로써 성능 저하를 방지하고 데이터 관리를 용이하게 하는 기법이다.
- 레인지/해시/리스트/컴포지트 파티셔닝
#### 테이블 분할
- 테이블 분할 기준에 따라 수평 분할/수직 분할로 구분한다.
## DB구조와 성능
### 1)슈퍼 타입과 서브 타입 데이터 모델의 성능 고려사항
#### 슈퍼타입과 서브타입 데이터 모델의 변환 방법
슈퍼 타입과 서브 타입 데이터 모델은 물리 모델링 단계에서 1:1 타입, 슈퍼+서브 타입, All in One타입으로 변환할 수 있다.
#### 슈퍼 타입과 서브타입 데이터 모델의 성능 고려사항
|고려사항|설명|
|:-:|-|
|개별 트랜잭션 발생||
|슈퍼 타입 + 서브 타입 트랜잭션 발생||
|전체 트랜잭션 발생||
### 2)기본키(PK), 외래키(FK) 성능 고려사항
- 기본키는 인덱스와 PK 컬럼 순서를 고려해야 하고, 외래키는 인덱스와 업무적 활용도를 고려해야 한다.
## 분산 데이터베이스 데이터에 따른 성능
### 1)분산 데이터베이스의 개념
- 분산 데이터베이스는 네트워크를 통해 물리적으로 분산된 데이터베이스를 하나의 논리적 데이터베이스로 사용하는 시스템이다.
- 다수의 지역으로 노드를 분산시켜 데이터베이스 성능을 향상시킨다.
- 분산 데이터베이스 구성으로 데이터 백업이 가능하지만, 데이터가 실시간으로 동기화 되지는 않는다.
### 2)분산 데이터베이스의 투명성
|투명성|설명|
|:-:|:-|
|지역사상 투명성|지역 DBMS와 물리적 DB 사이의 매핑을 보장하는 성질|
|중복 투명성|데이터가 다수의 물리적인 공간에 중복으로 저장되어 있는지 알 필요가 없는 성질|
|분할 투명성|하나의 논리적 릴레이션이 다수의 단편으로 분할되어 저장되는 성질|
|위치 투명성|데이터의 물리적인 위치를 명시할 필요가 없는 성질|
|장애 투명성|지역 데이터베이스, 네트워크 장애가 발생하더라도 데이터 무결성을 보존하는 성질|
|병행 투명성|다수의 트랜잭션을 수행해도 데이터의 일관성을 유지하는 성질|
### 3)분산 데이터베이스의 성능 고려사항
- 원거리 서버에 접속할 때 발생하는 네트워크 부하와 트랜잭션 집중 현상은 기존 데이터 베이스의 성능 저하를 발생시킨다.
- 데이터를 분산 환경으로 구성하면 근거리 서버 접속이 가능해져 Global Single Instance(GSI)<sub>통합 데이터베이스 구조</sub>보다 빠른 성능을 제공할 수 있다.

